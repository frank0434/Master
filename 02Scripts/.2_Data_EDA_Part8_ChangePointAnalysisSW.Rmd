---
title: "Data_EDA"
author: "jian (AKA Frank) liu"
date: "04/10/2019"
output:
  bookdown::html_document2:
              code_folding: hide
              toc: true
              toc_depth: 3
              fig_caption: yes
---

# Aim


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE,
                      fig.align = "center", fig.width = 10, fig.height = 7, 
                      dpi = 300)
options(scipen = 999)
#Constants
outlier.colour = "#ff0000"
source("R/packages.R")
source("R/functions.R")
con <- dbConnect(SQLite(), "../03processed-data/Richard.sqlite3")
dbListTables(con)
SowingDates <- dbReadTable(con, "SowingDates") %>% 
  as.data.table()

```

|		  |AD        | I12|
|:----|:-----|:------|
|SD1	|21-Oct-10|	4-Oct-10|
|SD2	|9-Nov-10|	4-Nov-10|
|SD3	|8-Dec-10|	2-Dec-10|
|SD4	|13-Jan-11	|10-Jan-11|
|SD5	|3-Feb-11|	7-Feb-11|
|SD6	|10-Oct-11	|10-Oct-11|
|SD7	|7-Nov-11|	7-Nov-11|
|SD8	|9-Dec-11|	9-Dec-11|
|SD9	|10-Jan-12	|10-Jan-12|
|SD10|	17-Feb-12	|17-Feb-12|


Figure \@ref(fig:OverallAD) A boxplot shows the range of SWC in AshleyDene over 2 years. 

```{r OverallAD, fig.cap='A boxplot shows the range of SWC in AshleyDene over 2 years.'}
water <- dbReadTable(con, "SoilWater", check.names = FALSE) %>% 
  as.data.table()

water[, ':='(Clock.Today = as.Date(Clock.Today))]
# [, SowingDate := factor(SowingDate, levels(SowingDate)[c(1,3:10, 2)])]
# Isolate SD 1 in AshleyDene
water[Experiment == "AshleyDene" ] %>% 
  ggplot(aes(Clock.Today, SWC, group = Clock.Today)) +
  # geom_point()+
  geom_boxplot(outlier.colour = outlier.colour, outlier.size = 5) +
  geom_text(aes(label = SowingDate), check_overlap = TRUE, size = 3) +
  theme_water()
dbDisconnect(con)

```

## 20200825

what if I only use the default settings. 
what the values will be?

```{r}

```



## 20200814 Try to derive the RFV FROM observed data 

```{r}
colnames(water)
water[Experiment == "AshleyDene" & SowingDate == "SD2"]  %>% 
  ggplot(aes(DAS, `SW(10)`)) +
  geom_point() +
  geom_smooth(se = FALSE,  method = "loess")
water[Experiment == "AshleyDene" & SowingDate == "SD2"]  %>% 
  ggplot(aes(`SW(10)`)) +
  geom_histogram()
```
```{r}
water = rename_cols(DT = water[, `SW(2)`:=NULL])
id_vars <- colnames(water)[!colnames(water) %in% grep("SW\\(\\d.+", colnames(water), value = TRUE)]
value_vars <- colnames(water)[!colnames(water) %in% id_vars]
id_vars = c("Experiment","Clock.Today", "Season","SowingDate", "DAS")
SW_mean <- water[, lapply(.SD, mean, na.rm = TRUE), by = id_vars, .SDcols = value_vars]
# Loadd the sw mean from drake cache with the top 2 layers combined
# loadd(SW_mean)
```
#### Select season one to see which layer the root have been 

```{r}
season1 = melt(SW_mean[Season == "2010/11"], id.vars = id_vars,
               variable.name = "Depth", value.name = "SW", 
               variable.factor = FALSE)
season1[, Depth := as.integer(gsub("\\D", "", Depth))]
season1[, SW := mean(SW,na.rm = TRUE), by = .(Experiment, Clock.Today, Season, SowingDate, DAS, Depth) ][]
season1 %>% 
  ggplot(aes(SW)) + 
  geom_histogram() + 
  facet_wrap(~ Experiment)
season1 %>% 
  ggplot(aes(SW)) + 
  geom_histogram() +
  scale_x_log10() +
  facet_wrap(~ Experiment)
```
#### Need to DUL and LL to calculate the relative water 
**Run chunch 7 to 14 to have the DUL and LL for each layer**
```{r}
loadd(SW_DUL_LL)
dul = SW_DUL_LL[,.(Experiment, SowingDate,Depth, DUL, LL, PAWC)]
season1 = merge(season1, dul, by = c("Experiment","SowingDate","Depth"),
                all.x = TRUE, suffixes = c("", "_started"))
season1[, ':='(relativeSW = SW/100/DUL,
               Depth = as.factor(Depth))][]

ADSD2 = season1[Experiment != "AshleyDene" & SowingDate == "SD2"]
ADSD2 %>% 
  ggplot(aes(DAS, relativeSW, color = Depth, group = Depth)) +
  # geom_point()+
  geom_smooth(se = FALSE, span = 0.3) +
  facet_wrap(~Depth) +
  theme_water() +
  ggtitle("Iversen12 Sowing Date 2")

```

## Test `mcp`

the term i looked for detecting the time of RFV is called **change point` analysis

`mcp` seems the most advanced package in thi field with a nice github page. 
https://lindeloev.github.io/mcp/index.html

[more comparison](https://www.marinedatascience.co/blog/2019/09/28/comparison-of-change-point-detection-methods/)

Formula format for segments
The format of each segment is generally response ~ changepoint ~ predictors + sigma(variance_predictors), except for the first segment where there is no change point (response ~ predictors + sigma(variance_predictors)). Here is a simple and a complex formula

The response is just the name of a column in your data.
The change point can be 1 for a population-level change point or 1 + (1|group) varying change points sampled around the population-level change point.
The predictors can be 0 (no change in intercept), 1 (change in intercept), and any column in your data which you want to model a slope on.
The variance predictors has itâ€™s own article, but they follow the same rules as the predictors.
```{r}
library(mcp)
# simple test
n = 17
dt = ADSD2[Depth == n]

# Build the model
model = list(
  relativeSW ~ 1  ,  # plateau (int_1)
   ~ 0 + DAS + sigma(0),       # joined slope (time_2) at cp_1, could be a exp decay function.
   ~ 0             # joined slope (int_3, time_3) at cp_2 - plateau
         # joined slope at cp_3 - infiltration front
  )

# Fit it.
fit = mcp(model, data = dt)
# plot(fit, prior = FALSE) + 
#   geom_vline(xintercept = summary(fit, width = 0.1)$mean[1])
# 
# plot(fit, prior = TRUE) + 
#   geom_vline(xintercept = summary(fit, width = 0.1)$mean[1])
# # l = summary(fit)
cp_1_est = as.data.table(summary(fit))
# cp_1_est
# int_range = cp_1_est[name == "int_1"]
# (int_range$upper - int_range$lower) < 0.05

setkey(dt, DAS)
dt = dt[dt[J(cp_1_est$mean[1]), roll = 'nearest', which = TRUE]]
close_das = dt$DAS
P = plot(fit) +
  geom_vline(xintercept = cp_1_est$mean[1], color =  c("red"))  +
  theme_water() 

P + geom_point(size = 5) +
  ggtitle(paste0("Iversen12 Layer ", n))
```


#### WHY THE CHANGE POINT IS GIVEN IN THAT PARTICULAR DATE? 
BEST FIT? 
MINIMUM COST? 
ANSWERS: 

summary.mcpfit returns the quantiles specified in the "width" argument. So for summary(fit, width = 0.95) it returns the 2.5% and 97.5% quantiles of the distributions you see as blue curves in the bottom of your plot.

Other comments: In your case, you have very little data to inform around 7 parameters, so I would guess that the prior excerts quite an influence on the results. Try doing mcp(model, data, sample = "both") and then compare plot(fit, prior = FALSE) with plot(fit, prior = TRUE). If they are somewhat similar, try explicitly setting the prior as basically anything will be better than the default, which merely serves to make the model run in most scenarios. Read more on the website. https://lindeloev.github.io/mcp/

```{r}

```

```{r}
# plot_pars(fit)

# varying the change points - this is a linear mixed effect model. probably not
# applicable in this case
# ADSD2[, Depth := as.integer(Depth)]
# # options(mc.cores = 2)
# model = list(
#   relativeSW ~ 1,  # plateau (int_1)
#   1 + (1|Depth) ~ 0 + DAS,    # joined slope (time_2) at cp_1
#   (1|Depth) ~ 0,
#   (1|Depth) ~ 0 + DAS
# 
# )

# Fit it. The `ex_demo` dataset is included in mcp
fit = mcp(model, data = ADSD2)
plot(fit)
summary(fit)

```

## Test `mcp` in one sowing date
```{r}
# Build the model
model = list(
  relativeSW ~ 1 ,  # plateau (int_1)
   ~ 0 + DAS,       # joined slope (time_2) at cp_1, could be a exp decay function.
   ~ 0  ,            # joined slope (int_3, time_3) at cp_2 - plateau
   ~ 0 + DAS        # joined slope at cp_3 - infiltration front
  )
set.seed(42)
ldpeth = lapply(2:22, function(n){
 dt = ADSD2[Depth == n]
 # range = max(dt$relativeSW, na.rm = TRUE) - min(dt$relativeSW, na.rm = TRUE)
 
   
  # Fit it. 
  fit = mcp(model, data = dt, cores = 3)
  # Extract the cp one 
  cp_1_est = as.data.table(summary(fit))
  int_range = cp_1_est[name == "int_1"]
  if((int_range$upper - int_range$lower) > 0.05){
    setkey(dt, DAS)
  
  close_das = dt[dt[J(cp_1_est$mean[1]), roll = 'nearest', which = TRUE]]$DAS
  P = plot(fit) +
    geom_vline(xintercept = c(cp_1_est$mean[1],close_das), 
               color =  c("red","black")) +
    ggtitle(n)+
    theme_water()
  
  
  return(P)
  } else(
   cat("Layer", n, "has less than 0.05 changes. Ignored. \r\n")
 )
  
})
ldpeth
# Check the top 
# DT = ADSD2[Depth ==11 & DAS < 145 ]
# # fit = mcp(model, data = DT, cores = 3, sample = 'both' )
# # Extract the cp one 
# cp_1_est = as.data.table(summary(fit ))
# plot(fit) + geom_vline(xintercept = cp_1_est$mean[1])
# plot_pars(fit) 
# int_range = cp_1_est[name == "int_1"]
str(ldpeth)
  
```

# 20200824 Try to find the distribution of initial soil conditions 


```{r}
season1[, .SD[1], by = .(Experiment, SowingDate, Depth)] %>% 
  ggplot(aes(relativeSW, fill = SowingDate)) + 
  # geom_density() +
  geom_histogram()+
  facet_wrap(~ Experiment)

season1[, .SD[1], by = .(Experiment, SowingDate, Depth)] %>% 
  ggplot(aes(SowingDate, relativeSW, color = SowingDate)) + 
  geom_boxplot(outlier.colour = "red", outlier.size = 3)+
  # geom_violin() +
  # geom_histogram()+
  facet_wrap(~ Experiment) + 
  geom_text(aes(label = Depth), nudge_y = -0.01, check_overlap = TRUE)
```


## Top layer 0-20cm are better to use indenpended model


```{r}
I12SD2 = season1[Experiment != "AshleyDene" & SowingDate == "SD2"]
ldpethi12=lapply(2:22, function(n){
  dt = I12SD2[Depth == n & DAS < 150]
 # range = max(dt$relativeSW, na.rm = TRUE) - min(dt$relativeSW, na.rm = TRUE)
 
   
  # Fit it. 
  fit = mcp(model, data = dt, cores = 3)
  # Extract the cp one 
  cp_1_est = as.data.table(summary(fit))
  int_range = cp_1_est[name == "int_1"]
  if((int_range$upper - int_range$lower) > 0.05){
    setkey(dt, DAS)
  
  close_das = dt[dt[J(cp_1_est$mean[1]), roll = 'nearest', which = TRUE]]$DAS
  P = plot(fit) +
    geom_vline(xintercept = c(cp_1_est$mean[1],close_das), 
               color =  c("red","black")) +
    ggtitle(n)+
    theme_water()
  
  
  return(P)
  } else(
   cat("Layer", n, "has less than 0.05 changes. Ignored. \r\n")
 )
  
})
ldpethi12
  
```
anything happens should be after the 2nd measurement since the first and 2nd are a bit far away

```{r}
model = list(
  relativeSW ~ 1 + sigma(1),  # plateau (int_1)
   ~ 0 + DAS ,       # joined slope (time_2) at cp_1, could be a exp decay function.
   ~ 0  
  )
prior = list(
  # Intercept should be between 0.5 and 1; less than 1
  ## Evidence in the hist above
  int_1 = "dnorm(0.5, 1) T(, 1)" 
)
I12SD2 = season1[Experiment == "AshleyDene" & SowingDate == "SD2"]
ldpethi12=lapply(1:22, function(n){
  # Cut the data before the rain fall
  dt = I12SD2[Depth == n & DAS < 150]
  # Fit it. 
  fit = mcp(model, data = dt, cores = 3, prior = prior)
  # Extract the cp one 
  cp_1_est = as.data.table(summary(fit))
  # int_range = cp_1_est[name == "int_1"]
  # if((int_range$upper - int_range$lower) > 0.05){
    setkey(dt, DAS)
  
  close_das = dt[dt[J(cp_1_est$mean[1]), roll = 'nearest', which = TRUE]]$DAS
  P = plot(fit) +
    geom_vline(xintercept = c(cp_1_est$mean[1],close_das), 
               color =  c("red","black")) +
    ggtitle(n)+
    theme_water()
  l = vector("list", 2)
  l[[1]] = fit
  l[[2]] = P
 
  l
  # } else(
   # cat("Layer", n, "has less than 0.05 changes. Ignored. \r\n")
 # )
  
})

I12SD2_fit = lapply(ldpethi12, function(x){
 fit = summary(x[[1]])

})
I12SD2_graph = lapply(ldpethi12, function(x){
  x[[2]]
})
I12SD2_graph[[1]]
```

analysis the cp
what is the variation in each depth regarding to the sw changes
**if sd is smaller than 0.05** then say there is no decrease of SW

```{r}
maxDepthS1 = I12SD2[, .(sd(relativeSW)), by = .(Depth)
       ][V1 > 0.05][, .N]

```

```{r}
summary(I12SD2_fit[[1]])
DT_fit = rbindlist(I12SD2_fit, use.names = TRUE, idcol = "Depth")
DT_fit[, variance := upper - lower]
I12SD2_RFV = DT_fit[name == "cp_1" & Depth <= maxDepthS1] %>% 
  ggplot(aes( mean, Depth)) +
  geom_point(size = 5)  +
  # coord_flip() +
  scale_y_reverse() +
  theme_water() +
  labs( x = "DAS")
```
FIRST CUT OCCURS IN 75 DAS
SECOND CUT OCCURS IN 127 DAS

Factors that may delay the RFV:
1. cutting 
2. rainfall
```{r}
# Check cuts
biomass = read_dbtab("../03processed-data/Richard.sqlite3", "biomass")
cuts = biomass[Experiment =="Iversen12" & SowingDate == "SD2", 
        .(Experiment, Clock.Today, Season, Rotation.No.,SowingDate, DAS )]

cuts_SD2 = unique(cuts)[, .SD[.N], by = .(Rotation.No., Season)]
I12SD2_RFV_CUT = I12SD2_RFV +
   geom_vline(data = cuts_SD2[Season == "2010/11" ], aes(xintercept = DAS), color = "red")  +
  annotate("text", x = 75 + 1, y = 25 , label = "Red Lines were cutting dates", size = 10) 

met = read_dbtab("../03processed-data/Richard.sqlite3", "met_Iversen12")
met_SD2 = met[year >=2010 & year < 2013
    ][, Clock.Today := as.Date(day, origin = paste0(year, "-01-01"))
      ][Clock.Today >= "2010-11-07" & Clock.Today < "2011-06-14"]
rain_SD2 = met_SD2[, DAS:= seq(3, nrow(met_SD2) + 2, 1)][,.(DAS, rain)]
I12SD2_RFV_CUT+
  geom_col(data = rain_SD2, aes(x = DAS, y = rain, fill = "Rainfall"), alpha= 0.5)+
  scale_fill_manual(name = "", values = (Rainfall = "blue"), ) +
  ggtitle(paste0(unique(cuts_SD2$Experiment), " ", unique(cuts_SD2$SowingDate)))+
  theme(panel.grid.major.y = element_line(colour = "grey50"),
        panel.grid.minor.y = element_line(colour = "grey80"))
# ggsave("../05figures/I12SD2.png", dpi = 300, height = 8, width = 8)
```


```{r}
SW_long = melt(SW_mean, id.vars = id_vars,
               variable.name = "Depth", value.name = "SW", 
               variable.factor = FALSE) 
SW_long[, Depth := as.integer(gsub("\\D", "", Depth))]
SW_long[, SW := mean(SW,na.rm = TRUE), by = .(Experiment, Clock.Today, Season, SowingDate, DAS, Depth) ][]
SW_long%>% 
  ggplot(aes(DAS, SW, color = Depth)) + 
  geom_point() +
  facet_grid(~ Experiment)
SW_long[Experiment == "Iversen12"] %>% 
   ggplot(aes(DAS, SW, color = Depth)) + 
  geom_point() +
  facet_wrap(~ Experiment+SowingDate)
SW_long[Experiment != "Iversen12"] %>% 
   ggplot(aes(DAS, SW, color = Depth)) + 
  geom_point() +
  facet_wrap(~ Experiment+SowingDate)

```


```{r}
I12SD2%>% 
  ggplot(aes(DAS, relativeSW, color = Depth, group = Depth)) +
  # geom_point()+
  geom_smooth(se = FALSE, span = 0.3) +
  facet_wrap(~Depth) 
```


```{r}
n = 4
# lapply(1:23, function(n){
  df=ADSD2[Depth == n]
  lms = lm(SW ~ DAS, df)
  summary(lms) 
  qplot(DAS, SW, data = broom::augment(lms)) + geom_line(aes(y = .fitted))

# })
```
WHAT ABOUT I12
```{r}
I12SD2 = season1[Experiment != "AshleyDene" & SowingDate == "SD2"]
lapply(1:23, function(n){
  X = I12SD2[Depth == n]$DAS
  y = I12SD2[Depth == n]$SW
  lms = roll_lm(X, y, width = 4)
  lmlayer1 = cbind(lms$coefficients, lms$r.squared, lms$std.error, X) 
  colnames(lmlayer1) = c("Intercept", "coef", "R2", "Intercept_sem", "sem", "DAS")
  critical = qt(0.05, df = 2) # How to decide this df? totoal df in one treatment?
  CI = as.data.table(lmlayer1)[, ci := coef - critical * sem]
  thechooseone = CI[coef < 0 & coef < ci & ci < 0]
  # thechooseone = lmlayer1[x1<CI][1] # not a good standard
  # t.test(lmlayer1$x1, mu =  0)
  plot(X, y)
  lines(X, y)
  title(n)
  abline(v = thechooseone$DAS, col = "red")
})
```



## roll lm
rolling lm seems not able to detect the true decline trend 
```{r}
library(roll)
lapply(1:23, function(n){
  X = ADSD2[Depth == n]$DAS
  y = ADSD2[Depth == n]$SW
  lms = roll_lm(X, y, width = 4)
  lmlayer1 = cbind(lms$coefficients, lms$r.squared, lms$std.error, X) 
  colnames(lmlayer1) = c("Intercept", "coef", "R2", "Intercept_sem", "sem", "DAS")
  critical = qt(0.05, df = 2) # How to decide this df? totoal df in one treatment?
  CI = as.data.table(lmlayer1)[, ci := coef - critical * sem]
  T = t.test(CI$coef)
  thechooseone = CI[coef < T$conf.int[1]]
  # thechooseone = lmlayer1[x1<CI][1] # not a good standard
  # t.test(lmlayer1$x1, mu =  0)
  plot(X, y)
  lines(X, y)
  title(n)
  abline(v = thechooseone$DAS, col = "red")
})

```

if the soil moisture can explained well by lm model in one layer,
it probably indicates that the root had not reached there. 

if the variance is less than a value 
then it is a strait line

```{r}
library(segmented)
n = 10
out.lm<-lm(relativeSW ~ DAS,data=ADSD2[Depth == n])
# qplot(DAS, relativeSW, data =broom::augment(out.lm)) + geom_line(aes(y = .fitted))

o<-segmented(out.lm,seg.Z=~DAS,
             psi=list(DAS = NA),
             # npsi = 4,
             control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 50, K=5, display=TRUE))
 
print(summary(o))
      
# find slopes and phyllochron
 s = slope(o)
 # find breaks
 b = o$psi[,2]
b
plot(ADSD2[Depth == n]$DAS,ADSD2[Depth == n]$relativeSW, cex=1.8, pch=01, family= "serif", xlab="", ylab="")
plot(o,lwd=3, add=TRUE)

par(mfrow=c(1,2))
draw.history(o, "DAS")
# draw.history(o, "z")
plot(o, conf.level=0.95, shade=TRUE)
```
## Try production with `segmented`

 
```{r}
lapply(1:22, function(n){
  out.lm<-lm(relativeSW ~ DAS,data=ADSD2[Depth == n])
# qplot(DAS, relativeSW, data =broom::augment(out.lm)) + geom_line(aes(y = .fitted))

o<-segmented(out.lm,seg.Z=~DAS,
             psi=list(DAS = NA),
             # npsi = 4,
             control=seg.control(fix.npsi=FALSE, n.boot=0, tol=1e-7, it.max = 50, K=5, display=TRUE))
 
# print(summary(o))
      
# find slopes and phyllochron
 s = slope(o)
 # find breaks
 b = o$psi[,2]

plot(ADSD2[Depth == n]$DAS,ADSD2[Depth == n]$relativeSW, cex=1.8, pch=01, family= "serif", xlab="", ylab="")
plot(o,lwd=3, add=TRUE)
title(n)
})

```

