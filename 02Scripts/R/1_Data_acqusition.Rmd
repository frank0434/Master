---
title: "Data_acquisition"
author: "jian (AKA Frank) liu"
date: "04/10/2019"
output:
  html_document: 
    code_folding: hide
    toc: true
    toc_depth: 3
---

```{r setup, include=FALSE,warning=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
source(here::here("02Scripts/R/packages.R"))
source(here::here("02Scripts/R/functions.R"))
```

## Richard data set into sqlite?

```{r richard, warning=FALSE, message=FALSE}
path_richard = "c:/Users/cflfcl/Dropbox/Data/APSIM_Sim.xlsx"
meta_data <- read_excel(path_richard)

dt = read_excel(path_richard, guess_max = 10300, sheet = 2,
                          .name_repair ="universal",
                          skip = 9 )%>% # fix the names 
  as.data.table() 


setnames(dt, c("Site", "Date", "Sowing.Date"), c("Experiment", "Clock.Today", "SowingDate"))
```

what **S AND E** MEANS? SOWING AND EMERGE?
Alpha|	Growth Stage|		No.
 ---|---|---
S|	Sowing	|	1
E	|Emergence	|	3
J	|Juvenile	|	4
Fi|	Visible Bud	|	5
Fl | Flower Open	|	6


_Note_
Richard excel file has mix variable types. `read_excel` has trouble to deal with it. try python's pandas
_Solution_ manually save it to `.txt`, `fread` can handle the type of variables 


### inspect the data

```{r main table}
colnames(dt)
# inspect_na(dt)
dt[, ...119 := NULL]

tbl <- inspect_cat(dt)
head(tbl)

# inspect the type of cols
col_type <- dt %>% 
  inspect_types()

# data and time cols
col_date <- col_type$col_name[[3]]
# change to NZ time zone and change to character 
# becuase sqlite not support Date in yyyymmdd
dt[, (col_date) := lapply(.SD, function(x) as.character(as.Date(x,  tz = "Pacific/Auckland"))), .SDcol = col_date]

```

_couldn't use `inspect_cat` because of duplicated colnames?_ Fixed by using `.name_repair` in `as_tibble`

There are two `Plant No.` variables.
One is the harvest area plant number and the other one is the plant number per $m^2$

_Note:_

1. the number of obs for Total.DM is larger than the obs for Total FW?
   **not really - there are missing values have been coded as 0**

2. there are multiply tables in one sheet. need to separate into different tables 



```{r main table col}
sapply(dt[,1:2], unique)
```


_Note_ 
1. Need to figure out what `ES` and `*` stands for.
**ES** should be evapotranspiration surface SWC 0-0.2m

2. same for the `Site` col.
3. same for the `Date` col, and the `Date` col need to be converted.
4. all the rest of cols have this `*`.


**The `*`** means the end of the main table. 

### chop the main table to separate tables 

need a function to figure out which col is not necessary 

```{r Biomass tab}
biomass <- dt[Data == "Biomass"]

col_good <- choose_cols(biomass) # identify the right cols 

biomass <- biomass[,..col_good] # subset the right cols

# drop the extra cols in place 

SowingDates <- biomass[!is.na(AD)][, .(SD =...120, AD = as.character(AD), I12 = as.character(I12))]
biomass[, c("...120", "AD", "I12") := NULL]
# biomass %>% 
#   inspect_na() %>% 
#   show_plot()

```

_Note_

Protein and MJME might be worth to be in a single table?

#### the ad and i12 represent sowing dates in two sites

```{r sowing dates tab}
sowingDate <- dt[,...120 : I12][!is.na(...120)]
setnames(sowingDate, "...120", "ID", skip_absent = TRUE)
```


```{r Root tab}

root <- dt[Data == "Root"]

col_good <- choose_cols(root) # identify the right cols 

root <- root[,..col_good]
# 
# inspect_na(root) %>% 
#   show_plot()
```


```{r Phenology tab}

Phenology <- dt[Data == "Phenology"]

col_good <- choose_cols(Phenology) # identify the right cols 

Phenology <- Phenology[,..col_good]
```

**retired**
```{r Soil water tab, eval=FALSE, include=FALSE}


SoilWater <- dt[Data == "Soil water"]

col_good <- choose_cols(SoilWater) # identify the right cols 

SoilWater <- SoilWater[,..col_good]
# Fix the colnames here 
# Fix the layer 

SoilWater[, Data:=NULL
          ][, SWC.0.1:= SWC.0.1 + SWC.0.2 # Add up the first two layers together to match APSIM soil
            ][, SWC.0.2 := NULL] # Drop the second layer

# New model separate the top 20 cm 

# Fix the name to match APSIM soil

swc_vars <- grep("SWC", colnames(SoilWater), value = TRUE)
setnames(SoilWater, swc_vars[-length(swc_vars)], paste0("SW(", seq(1, 22, 1), ")"))
setnames(SoilWater, "SWC.2.3.m..mm.", "SWC")
SoilWater[Experiment == "AshleyDene"]$Clock.Today %>% unique() %>% length()
SoilWater[Experiment != "AshleyDene"]$Clock.Today %>% unique() %>% length()
SoilWater[Experiment == "AshleyDene"][, mean(Rep), by = .(Clock.Today)]

```
```{r final version read soilwater, message=FALSE,warning=FALSE}
SoilWater <- read_Sims(path = path_richard)
```
```{r final version read sowing dates}
SowingDates <- read_Sims(path = path_richard, source = "sowingDate")
```



```{r ES tab}

ES <- dt[Data == "ES"]

col_good <- choose_cols(ES) # identify the right cols 

ES <- ES[,..col_good]
```


### Check again before lock into sqlite

```{r inspect types}
l <- list(biomass, root, Phenology, SoilWater, ES) # put into a list for quick inspection
l %>% 
  lapply(inspect_types)
l %>%
  lapply(colnames)
```

_Note:_

1. variable types are not right
2. `Plant.No....40` is the plant number in the harvest area.
3. `Plant.No....48` is the plant number per $m^2$
4. Phenology tab has biomass cols because missing values as 0s. 
5. The first 11 cols are the factors.
6. Variables in Phenology tab should not be change to numeric. 


```{r fix Phenology tab}
cols_11 <- colnames(dt)[1:11] # the master cols
cols_both <- colnames(Phenology)[colnames(Phenology) %in% colnames(biomass)] # the cols in both tabs
cols_inPheno <- colnames(Phenology)[cols_both %in% cols_11]
Phenology <- Phenology[,..cols_inPheno]
colnames(Phenology)
```


```{r fix the types}

#biomass tab

cols <- colnames(biomass)[!colnames(biomass) %in% cols_11] # the cols need to be converted 
biomass <- biomass[, (cols) := lapply(.SD, as.numeric), .SDcols = cols]
#root tab 

cols <- colnames(root)[!colnames(root) %in% cols_11] # the cols need to be converted 
root <- root[, (cols) := lapply(.SD, as.numeric), .SDcols = cols]
#soilwater tab

cols <- colnames(SoilWater)[!colnames(SoilWater) %in% cols_11] # the cols need to be converted 
SoilWater <- SoilWater[, (cols) := lapply(.SD, as.numeric), .SDcols = cols]
#es tab

cols <- colnames(ES)[!colnames(ES) %in% cols_11] # the cols need to be converted 
ES <- ES[, (cols) := lapply(.SD, as.numeric), .SDcols = cols]

```

_Note:_ 
There two cols has values been converted to NA by coercion. cautions going forward!!!


**Rerun** the chunck `inspect types`. everything seems awesome 


### Weather data 

What are the key dates to source the right climate data?

Dates|Event
----|----
21-Oct-10 | Sowing Date 1 in AD


MORE DATES IN THE `sqlite` file. 

There are quite a few `.met` files. 


```{r read mets}
climate_units <- read_met_col(here::here("01Data/ClimateAndObserved/lincoln.met"), skip = 6)
Iversen12 <- read_met(here::here("01Data/ClimateAndObserved/lincoln.met"))
head(Iversen12)

AshleyDene <- read_met(here::here("01Data/ClimateAndObserved/AshleyDene.met"))


```


### Lock tabs into sqlite 

```{r sqlite}

con <- dbConnect(SQLite(), here::here("01Data/ProcessedData/Richard.sqlite3"))
DBI::dbListTables(con)
# The sowing date tab first

# colnames(dt_SD_lookup)
# dbExecute(con," CREATE TABLE `SowingDate` (
#   `V120` TEXT NOT NULL,
#   `AD` TEXT NOT NULL,
#   `I12` TEXT NOT NULL,
#   PRIMARY KEY (V120)
# );
# ")

# dbWriteTable(con, "SowingDate", dt_SD_lookup, append = TRUE)# comment out once appended

# the rest 
# sqlite does not support ISO date. it will be julian date. 

# ls()
tab_names <- c("biomass",  "root", "Phenology","SoilWater","ES") 
purrr::map2(list(biomass, root, Phenology, SoilWater, ES), tab_names, ~ dbWriteTable(con, .y, .x, overwrite = TRUE))
dbWriteTable(con, "met_Iversen12", Iversen12, overwrite = TRUE)
dbWriteTable(con, "met_AshleyDene", AshleyDene, overwrite = TRUE)
dbWriteTable(con, "SowingDates", SowingDates, overwrite = TRUE)
dbWriteTable(con, "meta_data", meta_data, overwrite = TRUE)

DBI::dbDisconnect(con)
```

## Tidying Other datasets 

